{"ast":null,"code":"import { createLexer } from 'leac';\nimport * as p from 'peberminta';\nvar ast = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst lex = createLexer([{\n  name: 'ws',\n  regex: /[ \\t\\r\\n\\f]+/\n}, {\n  name: 'idn',\n  regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/\n}, {\n  name: '#id',\n  regex: /#[a-zA-Z0-9_-]+/\n}, {\n  name: 'str1',\n  regex: /'(?:\\\\['\\\\]|[^\\n'\\\\])*'/\n}, {\n  name: 'str2',\n  regex: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/\n}, {\n  name: '*'\n}, {\n  name: '.'\n}, {\n  name: ','\n}, {\n  name: '['\n}, {\n  name: ']'\n}, {\n  name: '='\n}, {\n  name: '>'\n}, {\n  name: '|'\n}, {\n  name: '+'\n}, {\n  name: '~'\n}, {\n  name: '^'\n}, {\n  name: '$'\n}]);\nfunction sumSpec(_ref, _ref2) {\n  let [a0, a1, a2] = _ref;\n  let [b0, b1, b2] = _ref2;\n  return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n  return ss.reduce(sumSpec, [0, 0, 0]);\n}\nfunction literal(name) {\n  return p.token(t => t.name === name ? true : undefined);\n}\nconst whitespace_ = p.token(t => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = p.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n  return p.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p.token(t => t.name === 'idn' ? t.text : undefined);\nconst hashId_ = p.token(t => t.name === '#id' ? t.text.slice(1) : undefined);\nconst string_ = p.token(t => t.name.startsWith('str') ? t.text.slice(1, -1) : undefined);\nconst namespace_ = p.left(p.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = p.eitherOr(p.ab(namespace_, identifier_, (ns, name) => ({\n  name: name,\n  namespace: ns\n})), p.map(identifier_, name => ({\n  name: name,\n  namespace: null\n})));\nconst uniSelector_ = p.eitherOr(p.ab(namespace_, literal('*'), ns => ({\n  type: 'universal',\n  namespace: ns,\n  specificity: [0, 0, 0]\n})), p.map(literal('*'), () => ({\n  type: 'universal',\n  namespace: null,\n  specificity: [0, 0, 0]\n})));\nconst tagSelector_ = p.map(qualifiedName_, _ref3 => {\n  let {\n    name,\n    namespace\n  } = _ref3;\n  return {\n    type: 'tag',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 0, 1]\n  };\n});\nconst classSelector_ = p.ab(literal('.'), identifier_, (fullstop, name) => ({\n  type: 'class',\n  name: name,\n  specificity: [0, 1, 0]\n}));\nconst idSelector_ = p.map(hashId_, name => ({\n  type: 'id',\n  name: name,\n  specificity: [1, 0, 0]\n}));\nconst attrModifier_ = p.token(t => {\n  if (t.name === 'idn') {\n    if (t.text === 'i' || t.text === 'I') {\n      return 'i';\n    }\n    if (t.text === 's' || t.text === 'S') {\n      return 's';\n    }\n  }\n  return undefined;\n});\nconst attrValue_ = p.eitherOr(p.ab(string_, p.option(p.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({\n  value: v,\n  modifier: mod\n})), p.ab(identifier_, p.option(p.right(whitespace_, attrModifier_), null), (v, mod) => ({\n  value: v,\n  modifier: mod\n})));\nconst attrMatcher_ = p.choice(p.map(literal('='), () => '='), p.ab(literal('~'), literal('='), () => '~='), p.ab(literal('|'), literal('='), () => '|='), p.ab(literal('^'), literal('='), () => '^='), p.ab(literal('$'), literal('='), () => '$='), p.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = p.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, _ref4) => {\n  let {\n    name,\n    namespace\n  } = _ref4;\n  return {\n    type: 'attrPresence',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 1, 0]\n  };\n});\nconst attrValueSelector_ = p.middle(literal('['), p.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), (_ref5, matcher, _ref6) => {\n  let {\n    name,\n    namespace\n  } = _ref5;\n  let {\n    value,\n    modifier\n  } = _ref6;\n  return {\n    type: 'attrValue',\n    name: name,\n    namespace: namespace,\n    matcher: matcher,\n    value: value,\n    modifier: modifier,\n    specificity: [0, 1, 0]\n  };\n}), literal(']'));\nconst attrSelector_ = p.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p.map(p.eitherOr(p.flatten(typeSelector_, p.many(subclassSelector_)), p.many1(subclassSelector_)), ss => {\n  return {\n    type: 'compound',\n    list: ss,\n    specificity: sumAllSpec(ss.map(s => s.specificity))\n  };\n});\nconst combinator_ = p.choice(p.map(literal('>'), () => '>'), p.map(literal('+'), () => '+'), p.map(literal('~'), () => '~'), p.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = p.eitherOr(optionallySpaced(combinator_), p.map(whitespace_, () => ' '));\nconst complexSelector_ = p.leftAssoc2(compoundSelector_, p.map(combinatorSeparator_, c => (left, right) => ({\n  type: 'compound',\n  list: [...right.list, {\n    type: 'combinator',\n    combinator: c,\n    left: left,\n    specificity: left.specificity\n  }],\n  specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = p.leftAssoc2(p.map(complexSelector_, s => ({\n  type: 'list',\n  list: [s]\n})), p.map(optionallySpaced(literal(',')), () => (acc, next) => ({\n  type: 'list',\n  list: [...acc.list, next]\n})), complexSelector_);\nfunction parse_(parser, str) {\n  const lexerResult = lex(str);\n  if (!lexerResult.complete) {\n    throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` + prettyPrintPosition(str, lexerResult.offset));\n  }\n  const result = optionallySpaced(parser)({\n    tokens: lexerResult.tokens,\n    options: undefined\n  }, 0);\n  if (!result.matched) {\n    throw new Error(`No match for \"${str}\" input!`);\n  }\n  if (result.position < lexerResult.tokens.length) {\n    const token = lexerResult.tokens[result.position];\n    throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` + prettyPrintPosition(str, token.offset, token.len));\n  }\n  return result.value;\n}\nfunction prettyPrintPosition(str, offset) {\n  let len = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n  return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n  return parse_(complexSelector_, str);\n}\nfunction serialize(selector) {\n  if (!selector.type) {\n    throw new Error('This is not an AST node.');\n  }\n  switch (selector.type) {\n    case 'universal':\n      return _serNs(selector.namespace) + '*';\n    case 'tag':\n      return _serNs(selector.namespace) + selector.name;\n    case 'class':\n      return '.' + selector.name;\n    case 'id':\n      return '#' + selector.name;\n    case 'attrPresence':\n      return `[${_serNs(selector.namespace)}${selector.name}]`;\n    case 'attrValue':\n      return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : ''}]`;\n    case 'combinator':\n      return serialize(selector.left) + selector.combinator;\n    case 'compound':\n      return selector.list.reduce((acc, node) => {\n        if (node.type === 'combinator') {\n          return serialize(node) + acc;\n        } else {\n          return acc + serialize(node);\n        }\n      }, '');\n    case 'list':\n      return selector.list.map(serialize).join(',');\n  }\n}\nfunction _serNs(ns) {\n  return ns || ns === '' ? ns + '|' : '';\n}\nfunction _serStr(str) {\n  if (str.indexOf('\"') === -1) {\n    return `\"${str}\"`;\n  } else if (str.indexOf(\"'\") === -1) {\n    return `'${str}'`;\n  } else {\n    return `\"${str.replace('\"', '\\\\\"')}\"`;\n  }\n}\nfunction normalize(selector) {\n  if (!selector.type) {\n    throw new Error('This is not an AST node.');\n  }\n  switch (selector.type) {\n    case 'compound':\n      {\n        selector.list.forEach(normalize);\n        selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n        break;\n      }\n    case 'combinator':\n      {\n        normalize(selector.left);\n        break;\n      }\n    case 'list':\n      {\n        selector.list.forEach(normalize);\n        selector.list.sort((a, b) => serialize(a) < serialize(b) ? -1 : 1);\n        break;\n      }\n  }\n  return selector;\n}\nfunction _getSelectorPriority(selector) {\n  switch (selector.type) {\n    case 'universal':\n      return [1];\n    case 'tag':\n      return [1];\n    case 'id':\n      return [2];\n    case 'class':\n      return [3, selector.name];\n    case 'attrPresence':\n      return [4, serialize(selector)];\n    case 'attrValue':\n      return [5, serialize(selector)];\n    case 'combinator':\n      return [15, serialize(selector)];\n  }\n}\nfunction compareSelectors(a, b) {\n  return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n  return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    throw new Error('Arguments must be arrays.');\n  }\n  const shorter = a.length < b.length ? a.length : b.length;\n  for (let i = 0; i < shorter; i++) {\n    if (a[i] === b[i]) {\n      continue;\n    }\n    return a[i] < b[i] ? -1 : 1;\n  }\n  return a.length - b.length;\n}\nexport { ast as Ast, compareSelectors, compareSpecificity, normalize, parse, parse1, serialize };","map":{"version":3,"names":["createLexer","p","ast","Object","freeze","__proto__","lex","name","regex","sumSpec","_ref","_ref2","a0","a1","a2","b0","b1","b2","sumAllSpec","ss","reduce","literal","token","t","undefined","whitespace_","optionalWhitespace_","option","optionallySpaced","parser","middle","identifier_","text","hashId_","slice","string_","startsWith","namespace_","left","qualifiedName_","eitherOr","ab","ns","namespace","map","uniSelector_","type","specificity","tagSelector_","_ref3","classSelector_","fullstop","idSelector_","attrModifier_","attrValue_","right","v","mod","value","modifier","attrMatcher_","choice","attrPresenceSelector_","abc","lbr","_ref4","attrValueSelector_","_ref5","matcher","_ref6","attrSelector_","typeSelector_","subclassSelector_","compoundSelector_","flatten","many","many1","list","s","combinator_","combinatorSeparator_","complexSelector_","leftAssoc2","c","combinator","listSelector_","acc","next","parse_","str","lexerResult","complete","Error","offset","prettyPrintPosition","result","tokens","options","matched","position","length","len","arguments","replace","m","r","padEnd","repeat","parse","parse1","serialize","selector","_serNs","_serStr","node","join","indexOf","normalize","forEach","sort","a","b","_compareArrays","_getSelectorPriority","compareSelectors","compareSpecificity","Array","isArray","shorter","i","Ast"],"sources":["E:/Programing/JavaScript/FrontEnd Mentor Projects/sign-up-form/node_modules/parseley/lib/parseley.mjs"],"sourcesContent":["import { createLexer } from 'leac';\nimport * as p from 'peberminta';\n\nvar ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst lex = createLexer([\n    { name: 'ws', regex: /[ \\t\\r\\n\\f]+/ },\n    { name: 'idn', regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },\n    { name: '#id', regex: /#[a-zA-Z0-9_-]+/ },\n    { name: 'str1', regex: /'(?:\\\\['\\\\]|[^\\n'\\\\])*'/ },\n    { name: 'str2', regex: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/ },\n    { name: '*' },\n    { name: '.' },\n    { name: ',' },\n    { name: '[' },\n    { name: ']' },\n    { name: '=' },\n    { name: '>' },\n    { name: '|' },\n    { name: '+' },\n    { name: '~' },\n    { name: '^' },\n    { name: '$' },\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [0, 0, 0]);\n}\nfunction literal(name) {\n    return p.token((t) => t.name === name ? true : undefined);\n}\nconst whitespace_ = p.token((t) => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = p.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return p.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p.token((t) => t.name === 'idn' ? t.text : undefined);\nconst hashId_ = p.token((t) => t.name === '#id' ? t.text.slice(1) : undefined);\nconst string_ = p.token((t) => t.name.startsWith('str') ? t.text.slice(1, -1) : undefined);\nconst namespace_ = p.left(p.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = p.eitherOr(p.ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), p.map(identifier_, (name) => ({ name: name, namespace: null })));\nconst uniSelector_ = p.eitherOr(p.ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), p.map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));\nconst tagSelector_ = p.map(qualifiedName_, ({ name, namespace }) => ({\n    type: 'tag',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 0, 1]\n}));\nconst classSelector_ = p.ab(literal('.'), identifier_, (fullstop, name) => ({\n    type: 'class',\n    name: name,\n    specificity: [0, 1, 0]\n}));\nconst idSelector_ = p.map(hashId_, (name) => ({\n    type: 'id',\n    name: name,\n    specificity: [1, 0, 0]\n}));\nconst attrModifier_ = p.token((t) => {\n    if (t.name === 'idn') {\n        if (t.text === 'i' || t.text === 'I') {\n            return 'i';\n        }\n        if (t.text === 's' || t.text === 'S') {\n            return 's';\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = p.eitherOr(p.ab(string_, p.option(p.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), p.ab(identifier_, p.option(p.right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));\nconst attrMatcher_ = p.choice(p.map(literal('='), () => '='), p.ab(literal('~'), literal('='), () => '~='), p.ab(literal('|'), literal('='), () => '|='), p.ab(literal('^'), literal('='), () => '^='), p.ab(literal('$'), literal('='), () => '$='), p.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = p.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({\n    type: 'attrPresence',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 1, 0]\n}));\nconst attrValueSelector_ = p.middle(literal('['), p.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({\n    type: 'attrValue',\n    name: name,\n    namespace: namespace,\n    matcher: matcher,\n    value: value,\n    modifier: modifier,\n    specificity: [0, 1, 0]\n})), literal(']'));\nconst attrSelector_ = p.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p.map(p.eitherOr(p.flatten(typeSelector_, p.many(subclassSelector_)), p.many1(subclassSelector_)), (ss) => {\n    return {\n        type: 'compound',\n        list: ss,\n        specificity: sumAllSpec(ss.map(s => s.specificity))\n    };\n});\nconst combinator_ = p.choice(p.map(literal('>'), () => '>'), p.map(literal('+'), () => '+'), p.map(literal('~'), () => '~'), p.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = p.eitherOr(optionallySpaced(combinator_), p.map(whitespace_, () => ' '));\nconst complexSelector_ = p.leftAssoc2(compoundSelector_, p.map(combinatorSeparator_, (c) => (left, right) => ({\n    type: 'compound',\n    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],\n    specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = p.leftAssoc2(p.map(complexSelector_, (s) => ({ type: 'list', list: [s] })), p.map(optionallySpaced(literal(',')), () => (acc, next) => ({ type: 'list', list: [...acc.list, next] })), complexSelector_);\nfunction parse_(parser, str) {\n    const lexerResult = lex(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` +\n            prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` +\n            prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\n\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'universal':\n            return _serNs(selector.namespace) + '*';\n        case 'tag':\n            return _serNs(selector.namespace) + selector.name;\n        case 'class':\n            return '.' + selector.name;\n        case 'id':\n            return '#' + selector.name;\n        case 'attrPresence':\n            return `[${_serNs(selector.namespace)}${selector.name}]`;\n        case 'attrValue':\n            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${(selector.modifier ? selector.modifier : '')}]`;\n        case 'combinator':\n            return serialize(selector.left) + selector.combinator;\n        case 'compound':\n            return selector.list.reduce((acc, node) => {\n                if (node.type === 'combinator') {\n                    return serialize(node) + acc;\n                }\n                else {\n                    return acc + serialize(node);\n                }\n            }, '');\n        case 'list':\n            return selector.list.map(serialize).join(',');\n    }\n}\nfunction _serNs(ns) {\n    return (ns || ns === '')\n        ? ns + '|'\n        : '';\n}\nfunction _serStr(str) {\n    if (str.indexOf('\"') === -1) {\n        return `\"${str}\"`;\n    }\n    else if (str.indexOf(\"'\") === -1) {\n        return `'${str}'`;\n    }\n    else {\n        return `\"${str.replace('\"', '\\\\\"')}\"`;\n    }\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'compound': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n            break;\n        }\n        case 'combinator': {\n            normalize(selector.left);\n            break;\n        }\n        case 'list': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);\n            break;\n        }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch (selector.type) {\n        case 'universal':\n            return [1];\n        case 'tag':\n            return [1];\n        case 'id':\n            return [2];\n        case 'class':\n            return [3, selector.name];\n        case 'attrPresence':\n            return [4, serialize(selector)];\n        case 'attrValue':\n            return [5, serialize(selector)];\n        case 'combinator':\n            return [15, serialize(selector)];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error('Arguments must be arrays.');\n    }\n    const shorter = (a.length < b.length) ? a.length : b.length;\n    for (let i = 0; i < shorter; i++) {\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return (a[i] < b[i]) ? -1 : 1;\n    }\n    return a.length - b.length;\n}\n\nexport { ast as Ast, compareSelectors, compareSpecificity, normalize, parse, parse1, serialize };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}